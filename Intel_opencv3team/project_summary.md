# **Qt & OpenCV 기반 파노라마 사진 편집기 프로젝트 기술 분석**

## **1. 프로젝트 개요**

본 프로젝트는 Qt 프레임워크를 사용하여 GUI를 구축하고, 강력한 컴퓨터 비전 라이브러리인 OpenCV를 핵심 엔진으로 활용하여 제작한 파노라마 사진 편집 프로그램입니다. 주요 기능으로는 여러 장의 사진을 한 장의 파노라마 이미지로 합성하는 기능과, 완성된 이미지에 다채로운 필터 및 프레임을 적용하는 편집 기능이 있습니다.

- **개발 환경:** C++, Qt Framework
- **핵심 라이브러리:** OpenCV 4.5.4

---

## **2. 주요 기능별 구현 로직 및 핵심 개념**

### **가. 파노라마 이미지 생성**

#### **기능 설명**
사용자가 웹캠을 통해 촬영한 여러 장의 이미지를 입력받아, 이미지들이 자연스럽게 이어지는 한 장의 넓은 파노라마 이미지로 자동 합성합니다.

#### **발표 키워드 (핵심 OpenCV 개념)**
- **`cv::Stitcher` 클래스:** OpenCV에서 제공하는 고수준 이미지 스티칭(Stitching) 클래스.
- **특징점 검출 및 매칭 (Feature Detection & Matching):** 이미지의 주요 지점을 찾아 서로 다른 이미지 간의 동일한 지점을 연결하는 과정. (e.g., SIFT, SURF 알고리즘)
- **호모그래피 (Homography):** 한 평면(이미지)을 다른 관점의 평면으로 변환하는 행렬. 이미지들을 하나의 공통된 평면에 정렬하기 위해 사용.
- **이미지 블렌딩 (Image Blending):** 이미지 간의 경계선을 부드럽게 처리하여 자연스러운 결과물을 만드는 기술.
- **후처리 (Post-processing):** 결과물의 완성도를 높이기 위한 추가 작업.

#### **구현 로직 (`stitch_images.cpp`)**
1.  **Stitcher 객체 생성:** `cv::Stitcher::create()` 함수를 통해 이미지 스티칭을 수행할 객체를 생성합니다.
2.  **이미지 합성:** `stitcher->stitch()` 함수에 사용자가 촬영한 이미지들(`std::vector<cv::Mat>`)을 전달합니다. 이 함수 내부에서 OpenCV는 다음의 복잡한 과정을 자동으로 처리합니다.
    - 각 이미지에서 수백 개의 **특징점**을 찾습니다.
    - 이미지들을 서로 비교하며 동일한 **특징점을 연결(매칭)**하여 이미지 간의 관계를 파악합니다.
    - 매칭된 점들을 기반으로 **호모그래피 행렬**을 계산하여 모든 이미지를 하나의 관점으로 변환 및 정렬합니다.
    - 정렬된 이미지의 경계선이 보이지 않도록 **블렌딩** 처리하여 최종 파노라마 이미지를 생성합니다.
3.  **검은 여백 제거 (후처리):** 스티칭 직후의 결과물은 주변부에 불규칙한 검은 여백이 생깁니다. 저희 프로젝트에서는 `crop_nonblack`이라는 커스텀 함수를 구현하여, 유효한 이미지 영역 내에서 **가장 큰 직사각형**을 계산하고 그 부분만 잘라내어 깔끔한 최종 결과물을 얻도록 개선했습니다.

---

### **나. 이미지 필터 기능**

#### **기능 설명**
완성된 파노라마 이미지에 '뽀샤시', '필름', '세피아' 등 다양한 아날로그 및 예술적 감성의 필터를 적용합니다.

#### **발표 키워드 (핵심 OpenCV 개념)**
- **`cv::bilateralFilter`:** 경계선은 유지하면서 노이즈를 제거하는 스마트 블러 필터.
- **`cv::addWeighted`:** 두 이미지(또는 값)를 가중치를 주어 합치는 함수.
- **`cv::randn`:** 특정 분포(정규분포)를 따르는 랜덤 노이즈를 생성하는 함수.
- **`cv::transform`:** 행렬 변환을 통해 이미지의 모든 픽셀 값을 일괄적으로 변경하는 함수.
- **커널 행렬 (Kernel Matrix):** 픽셀 변환 규칙을 담고 있는 행렬.

#### **구현 로직 (`mainwindow.cpp`)**

1.  **뽀샤시 필터 (`applyBeautyFilter`)**
    - `cv::bilateralFilter`를 적용하여 피부처럼 넓은 영역은 부드럽게 만들면서도, 눈매나 입술 같은 경계선은 선명하게 유지합니다.
    - 원본 이미지와 필터가 적용된 이미지를 `cv::addWeighted` 함수로 7:3 비율로 혼합하여, 원본의 디테일과 부드러운 질감이 공존하는 화사한 효과를 만들어냅니다.

2.  **필름 필터 (`applyFilmGrainFilter`)**
    - `cv::randn` 함수를 사용하여 이미지 전체에 미세한 랜덤 노이즈(Grain)를 생성합니다.
    - 원본 이미지에 이 노이즈를 더하여(`cv::add`), 마치 필름 카메라로 찍은 듯한 거친 질감을 표현합니다.

3.  **세피아 필터 (`applySepiaFilter`)**
    - 세피아 톤 변환을 위한 3x3 **커널 행렬**을 정의합니다. 이 행렬에는 각 BGR 채널 값을 어떻게 조합하여 새로운 갈색 톤의 BGR 값을 만들지에 대한 규칙이 담겨 있습니다.
    - `cv::transform` 함수에 원본 이미지와 세피아 커널 행렬을 전달합니다. 이 함수는 이미지의 모든 픽셀에 대해 행렬 곱셈을 수행하여 이미지를 한 번에 세피아 톤으로 변환합니다.

---

### **다. 프레임 적용 기능**

#### **기능 설명**
자동 얼굴 인식을 통해 얼굴에 프레임을 씌우거나, 사용자가 직접 지정한 영역에 프레임을 적용하는 두 가지 모드를 제공합니다. 또한, 최종 이미지 전체에 액자를 추가할 수 있습니다.

#### **발표 키워드 (핵심 OpenCV 개념)**
- **`cv::CascadeClassifier`:** 학습된 XML 파일을 기반으로 이미지 내 객체를 검출하는 분류기.
- **Haar Cascade (`haarcascade_frontalface_default.xml`):** 얼굴 정면 특징을 학습한 데이터 파일.
- **`detectMultiScale()`:** 이미지 내에서 다양한 크기의 객체(얼굴)를 검출하는 함수.
- **알파 채널 (Alpha Channel):** 이미지의 투명도 정보. PNG 파일의 배경을 투명하게 처리하는 데 사용.
- **ROI (Region of Interest, 관심 영역):** 이미지 내에서 특정 연산을 수행할 사각형 영역.
- **`cv::copyMakeBorder`:** 이미지의 가장자리를 확장하여 테두리를 추가하는 함수.
- **마우스 이벤트 처리 (Qt `eventFilter`):** GUI 환경에서 사용자의 마우스 입력을 감지하는 기능.

#### **구현 로직 (`mainwindow.cpp`)**

1.  **자동 얼굴 인식 프레임 (`applyFaceMask`)**
    - `cv::CascadeClassifier`에 `haarcascade_frontalface_default.xml` 파일을 로드합니다.
    - `detectMultiScale()` 함수로 이미지에서 얼굴 영역(`cv::Rect`)들을 찾습니다.
    - 각 얼굴 영역을 **ROI**로 지정하고, 투명한 배경을 가진 프레임 PNG 파일의 **알파 채널**을 마스크로 사용하여 프레임의 그림 부분만 ROI 위에 덧씌웁니다.

2.  **수동 프레임 그리기**
    - Qt의 `eventFilter`를 통해 이미지 라벨 위에서의 마우스 클릭, 드래그, 버튼 떼기 이벤트를 감지합니다.
    - 사용자가 드래그하여 그린 사각형의 좌표(`QRect`)를 기록합니다.
    - 사용자가 프레임 종류를 선택하면, 이 사각형 좌표를 이미지 좌표계로 변환하여 **ROI**를 설정하고, 자동 인식 방식과 동일한 로직으로 프레임을 적용합니다.

3.  **전체 액자 추가 (`onAddBorderFrameClicked`)**
    - `cv::copyMakeBorder` 함수를 사용하여 현재 이미지의 상하좌우에 일정한 두께의 테두리(Border)를 추가한 더 큰 이미지를 생성합니다.
    - `cv::rectangle` 함수를 이용해 테두리 영역에 몇 개의 사각형을 다른 색상과 두께로 겹쳐 그려 클래식한 액자 디자인을 표현합니다.
